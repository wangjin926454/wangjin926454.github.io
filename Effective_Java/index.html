<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" type="text/css" href="../css/css.css">
    <script src="../js/js.js"></script>
</head>
<body>
<div id="body1">
    <h2>Effective Java</h2>
    <h3>第一条 考虑用静态工厂方法代替构造函数</h3>
        ·好处1：与构造函数不同、静态工厂方法具有名字，能更确切地描述作用、更易于使用<br>
        ·好处2：1）与构造函数不同，每次被调用的时候，不要求非得创建一个新的对象。对于非可变类、<br>
    可以使用一个预先构造好的实例缓存起来，避免重复对象。类似单例模式。<br>
        2）使非可变类不会有两个相等的实例存在。即当且仅当a==b的时候才有a.equals(b)为true<br>
        那么客户端可以用==操作符来代替equals(Object)方法<br>
    ·好处3：静态工厂方法可以返回一个原类型的子类型的对象。例如在Collections中，一个API可以返回一个对象<br>
        同时又不使该对象的类成为公有的。<br>

    <h3>第二条 使用私有构造函数强化singleton属性</h3>
        1）在创建单例模式的时候，构造函数使用private、保证唯一实例对象只能通过getInstance()方法获得<br>
        2）为了使一个singleton类变成可序列化的(serializable)，仅仅在类中"implements Serializable"是<br>
    不够的，为了维护singleton方法，必须提供一个readResolve方法。从内存读出而组装的对象破坏<br>
    了单例的规则。单例是要求一个JVM中只有一个类对象的，而现在通过反序列，一个新的对象克隆了<br>
    出来。违反的单例的原则.使用readResolve方法，当JVM从内存中反序列化地"组装"一个新对象时，<br>
    就会自动调用这个 readResolve方法来返回指定的对象。<br>

    <h3>第三条 通过私有的构造函数强化不可实例化的能力</h3>
        1）不希望工具类实例化也防止工具类被实例化。最好的办法是提供一个私有的构造函数来防止工具类被实例化。<br>

    <h3>第四条 避免创建重复的对象</h3>
        1）在某些对象初始化之后不会改变时、尽量避免重复创建对象。使其作为static块和static final常量。<br>

    <h3>第五条 消除过期的对象引用</h3>
        1)当客户程序不再引用某些对象时，这些对象应该被回收。但是可能还会存在对这些对象的过期引用，即不用但是<br>
    却无意间存在引用。当一个对象过期时，应该情况这些引用，即指向null。如果还有引用会抛出NullPointException<br>
    所以无需担心系统会错误得运行下去。<br>
        2）
    ①内存泄露的另一个常见来源是缓存。可以使用WeakHashMap来代表缓存，当缓存中的条目过期之后,<br>
    他们会自动被删除。时间越久有的对象越没有价值，缓存应该尽可能地清除掉无用的条目，这项工作可以由<br>
    java.util.Timer API来完成。<br>
    ②或者可以在加入新条目的时候做清理工作。在1.4jdk以后中加入的<br>
    java.util.LinkedHashMap类完成，利用它的removeEldestEntry方法可以实现。<br>
    ②最简单易用;在LinkedHashMap添加元素后，会调用removeEldestEntry防范，<br>
    传递的参数时最久没有被访问的键值对，如果方法返回true，这个最久的键值对就会被删除。<br>
    LinkedHashMap中的实现总返回false，该子类重写后即可实现对容量的控制<br>

    <h3>第六条 避免使用终结函数（垃圾回收）</h3>
        从一个对象变得不可达到它的终结函数执行这段时间是任意的、不确定的。意味着时间关键的<br>
    任务不应该由终结函数来完成。例如打开的文件，应当由程序员自己关闭。由于JVM会延迟执行<br>
    所以大量文件保留在打开状态，当一个程序不能在打开文件的时候，它可能会执行失败。<br>
    不要被System.gc和System.runFinalization这两个方法所诱惑。增加终结函数被执行的机会<br>
    但是不保证会执行。<br>
        正常情况下一个未被捕获的异常将会使线程终止，并打印出栈轨迹。但是如果异常<br>
    发生在一个终结函数中，甚至连警告都不会打印出来。<br>
        例如在文件流或者数据库连接中提供一个显示的终结方法，通常与try-finally结构结合使用。以确保<br>
    及时终止。<br>
        终结函数只是用来充当"安全网"的角色。迟一点释放总比不释放要好。如果子类重写了终结函数，应当<br>
    在finally中调用super.finalize()<br>
    如果担心忘记调用super.finalize()，可以使用<br>
    public class Foo{<br>
        private final Object finalizerGuardian = new Object(){<br>
            //子类终结函数守卫者<br>
            protected void finalize() throws Throwable{<br>
    &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp }<br>
    &nbsp &nbsp &nbsp &nbsp  }<br>
    }<br>
    子类实例在私有实例域中保存着一个对其守卫者的唯一引用。守卫者被终结的时候，执行子类实例所期望的终结行为<br>
    
    <h3>第七条 在改写equals的时候请遵守通用约定</h3>
    <h4>不用覆盖equals的情形：</h4><br>
        1.类的每个实例本质上都是唯一的。<br>
    对于像Thread这类代表活动实体而不是值的类，尤为如此。<br>
        2.不关心类是否提供了“逻辑相等”的测试功能。<br>
    像java.util.Random这样，提供equals毫无意义。<br>
        3.超类已经覆盖了equals，从超类继承过来的行为对于子类也是合适的。<br>
    例如，骨架类AbstractList、AbstractSet、AbstractMap。<br>
        4.类是私有的或是包级私有的，可以确定它的equals方法永远不会被调用。<br>
        <h4>需要覆盖equals的情形：</h4><br>
        1.当程序员需要以特有的"逻辑相等"的方式进行比较时。而且超类也没有改写equals以实现期望的行为。<br>
    需要改写equals方法。有时候需要比较逻辑上是否相等（例如字符串只比较字符是否一样而不是内存地址）<br>
    而不是指向同一个对象。改写时也必须改写hashCode方法，使得这个类的实例可以被用作Map中的key，或者Set<br>
    中的元素。<br>
    ps:如果不重写hashCode：类对象作为map中的key。假设<br>
    Student s = new Student();<br>
    map.put(s,123);<br>
    此时再<br>
    Student s1 = new Student();<br>
    map.put(s1,456);<br>
    此时s1.equals(s)返回true.但是hashCode方法是调用Object中hashCode方法，计算值不一致。在Map时，得到两个key<br>
    equals相等，却以不同的key，value存储无法确定是否相等。所以应该重写hashCode方法。<br>
        2.枚举类型不要求改写equals方法。枚举类型保证每一个值只存在一个对象(单例模式)。
        3.equals方法实现了等价关系
    自反性：对于任意的引用值x，x.equals(x)一定为true<br>
    对称性：对于任意的x和y，y.equals(x)返回true时，x.equals(y)也一定返回true。<br>
    传递性：对于任意的x,y,z，如果x.equals(y)返回true,并y.euqlas(z)返回true时，x.equals(z)也一定返回true<br>
    一致性：对于任意的x和y,如果equals比较的对象信息没有被修改的话，要么都返回true，要么都返回false。<br>
    对于任意的x,x.equals(null)一定返回false。<br>
        4.equals方法重写指南<br>
    1.使用==判断"实参"是否指向对象的同一个引用。如果是返回true(String中equals方法）<br>
    2.使用instanceof操作符检查"实参"是否为正确的类型。如果不是直接返回false。（String中equals方法）<br>
    3.把实参转换到正确的类型(String中equals方法)<br>
    4.继续判断equals<br>
    5.equals(Object another)注意参数类型为Object<br>
    
    
    <h3>第八条 改写equals时总是要改写hashCode</h3><br>
        hashCode约定。来自java.lang.Object规范<br>
        1.应用程序执行期间一个对象的equals方法没有被修改的话，多次调用hashCode方法都应该返回同一个整数。<br>
    程序多次执行，这个整数可以不同。（应该是重启程序计算hashCode方法会改变）<br>
        2.如果两个对象equals方法相等。则hashCode方法也应产生相同的结果<br>
        3.如果两个对象equals（Object)方法不相等。那么两个hashCode不必产生相同的整数结果。有助于提高<br>
    hash table的性能。<br>
        4.如果更好的保持hash table的性能，交给科学家数学家去做。<br>
        5.不要试图从hashCode计算中排除掉一个关键部分以提高性能，有可能计算hashCode的时候非常快，但是<br>
    在Map中可能hash的不够均匀分散。在jdk1.2之前，String的hashCode只检查16个字符，对于像URL这样的层次状名字<br>
    的大型集合，性能将会严重下降。<br>
    
    <h3>第九条 总是要改写toString</h3><br>
        1.重写一个toString()方法。 在编程时显得很有必要(深有体会)<br>

    <h3>第十条 谨慎改写clone</h3>
        1.如果一个类实现了Cloneable，则Object的clone方法返回该对象的逐域拷贝<br>
    否则，抛出一个CloneNotSupportedException异常。不值得效仿，实现一个接口是表名一个<br>
    类可以为客户做某些事情，对于Cloneable接口，改变了超类中一个受保护的方法的行为。
        2.在java.lang.Object中对于clone的规范
    x.clone()!=x 返回true
    x.clone().getClass()==x.getClass()将返回true
    x.clone().equals(x)返回true。但是这些不是一个绝对的要求
        3.拷贝一个对象往往会导致创建该类的一个新实例，但同时它会要求拷贝内部的数据结构。
    这个过程中没有调用构造函数。
555555
    
</div>
</body>
</html>
