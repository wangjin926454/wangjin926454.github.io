<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" type="text/css" href="../css/css.css">
</head>
<body>
<div class="body">
    <h2>Effective Java</h2>
    <h3>第一条 考虑用静态工厂方法代替构造函数</h3>
    ·好处1：与构造函数不同、静态工厂方法具有名字，能更确切地描述作用、更易于使用<br>
    ·好处2：1）与构造函数不同，每次被调用的时候，不要求非得创建一个新的对象。对于非可变类、<br>
        可以使用一个预先构造好的实例缓存起来，避免重复对象。类似单例模式。<br>
    2）使非可变类不会有两个相等的实例存在。即当且仅当a==b的时候才有a.equals(b)为true<br>
        那么客户端可以用==操作符来代替equals(Object)方法<br>
    ·好处3：静态工厂方法可以返回一个原类型的子类型的对象。例如在Collections中，一个API可以返回一个对象<br>
        同时又不使该对象的类成为公有的。<br>

    <h3>第二条 使用私有构造函数强化singleton属性</h3>
    1）在创建单例模式的时候，构造函数使用private、保证唯一实例对象只能通过getInstance()方法获得<br>
    2）为了使一个singleton类变成可序列化的(serializable)，仅仅在类中"implements Serializable"是<br>
        不够的，为了维护singleton方法，必须提供一个readResolve方法。从内存读出而组装的对象破坏<br>
        了单例的规则。单例是要求一个JVM中只有一个类对象的，而现在通过反序列，一个新的对象克隆了<br>
        出来。违反的单例的原则.使用readResolve方法，当JVM从内存中反序列化地"组装"一个新对象时，<br>
        就会自动调用这个 readResolve方法来返回指定的对象。<br>

    <h3>第三条 通过私有的构造函数强化不可实例化的能力</h3>
    1）不希望工具类实例化也防止工具类被实例化。最好的办法是提供一个私有的构造函数来防止工具类被实例化。<br>

    <h3>第四条 避免创建重复的对象</h3>
    1）在某些对象初始化之后不会改变时、尽量避免重复创建对象。使其作为static块和static final常量。<br>

    <h3>第五条 消除过期的对象引用</h3>
    1)当客户程序不再引用某些对象时，这些对象应该被回收。但是可能还会存在对这些对象的过期引用，即不用但是<br>
        却无意间存在引用。当一个对象过期时，应该情况这些引用，即指向null。如果还有引用会抛出NullPointException<br>
        所以无需担心系统会错误得运行下去。
    2）
        ①内存泄露的另一个常见来源是缓存。可以使用WeakHashMap来代表缓存，当缓存中的条目过期之后,<br>
        他们会自动被删除。时间越久有的对象越没有价值，缓存应该尽可能地清除掉无用的条目，这项工作可以由<br>
        java.util.Timer API来完成。
        ②或者可以在加入新条目的时候做清理工作。在1.4jdk以后中加入的<br>
        java.util.LinkedHashMap类完成，利用它的removeEldestEntry方法可以实现。<br>
        ②最简单易用;在LinkedHashMap添加元素后，会调用removeEldestEntry防范，<br>
        传递的参数时最久没有被访问的键值对，如果方法返回true，这个最久的键值对就会被删除。<br>
        LinkedHashMap中的实现总返回false，该子类重写后即可实现对容量的控制<br>

</div>
</body>
</html>